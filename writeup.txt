Our strategy involved smashing immediately as soon as we smooshed a fruit. This turned out to be the most optimal strategy for us. Our bot starts off by moving to the bottom of the grid and searching for the first fruit in the array. After finding the first fruit's x-coord and determining whether we need to move left or right to catch it, we loop on this process again. Thus we continually load the bot's x-coordinate and the fruit's x-coordinate, determining whether we need to move left or right to catch it. This allows us to catch fruits that have an x-velocity because we will continue to move left or right if the x-coordinate of the fruit changes too. Then we altered our solve solution code to return a linked list but for this we had to create a seperate node for our head and then concatenate that with the rest of our linked list which would be built recursively. We also ensured that our puzzle interrupts were being carried properly and used almost a linear search to find our solution in the puzzle. Our biggest optimization was that we tried to find the best balance between number of puzzles to solve when we hit our out of energy interrupt and the number of puzzles we solve initially so that we don't lose time or have any useless excess energy at the end of all the cycles. Moreover, we also implemented moving our bot up towards the fruit that we had located as to be above our opponent if we were targeting the same fruit. We also cleared out our node memory several times to ensure there was no overflow and that there was space for new data. Our plan was to try to decrease the number of random allocation of "winner" on any fruit based on the fact that if both bots in a tournament got to the fruit at the same time, it would randomly give points to one bot. This was our plan to stay ahead of our opponent. 
